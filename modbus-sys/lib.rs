/* originally generated by rust-bindgen, then modified */

/*
#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
         */

extern crate libc;
use libc::{c_int, c_char, c_uint, c_long, c_double, c_void, size_t};
use libc::c_ulong;
use libc::{uint8_t, uint16_t, uint32_t, uint64_t};

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed24 {
    MODBUS_EXCEPTION_ILLEGAL_FUNCTION = 1,
    MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS = 2,
    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE = 3,
    MODBUS_EXCEPTION_SLAVE_OR_SERVER_FAILURE = 4,
    MODBUS_EXCEPTION_ACKNOWLEDGE = 5,
    MODBUS_EXCEPTION_SLAVE_OR_SERVER_BUSY = 6,
    MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE = 7,
    MODBUS_EXCEPTION_MEMORY_PARITY = 8,
    MODBUS_EXCEPTION_NOT_DEFINED = 9,
    MODBUS_EXCEPTION_GATEWAY_PATH = 10,
    MODBUS_EXCEPTION_GATEWAY_TARGET = 11,
    MODBUS_EXCEPTION_MAX = 12,
}
pub enum _modbus { }
pub type modbus_t = _modbus;
// Doing this one by hand
/*
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct modbus_mapping_t {
    pub nb_bits: c_int,
    pub start_bits: c_int,
    pub nb_input_bits: c_int,
    pub start_input_bits: c_int,
    pub nb_input_registers: c_int,
    pub start_input_registers: c_int,
    pub nb_registers: c_int,
    pub start_registers: c_int,
    pub tab_bits: *mut uint8_t,
    pub tab_input_bits: *mut uint8_t,
    pub tab_input_registers: *mut uint16_t,
    pub tab_registers: *mut uint16_t,
}
impl ::std::default::Default for modbus_mapping_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
*/

pub enum modbus_mapping_e { }
pub type modbus_mapping_t = modbus_mapping_e;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum modbus_error_recovery_mode {
    MODBUS_ERROR_RECOVERY_NONE = 0,
    MODBUS_ERROR_RECOVERY_LINK = 2,
    MODBUS_ERROR_RECOVERY_PROTOCOL = 4,
}

extern {
    pub static mut _sys_siglist: [*const c_char; 65usize];
    pub static mut sys_siglist: [*const c_char; 65usize];
    pub static libmodbus_version_major: c_uint;
    pub static libmodbus_version_minor: c_uint;
    pub static libmodbus_version_micro: c_uint;
}

extern {
    pub fn modbus_set_slave(ctx: *mut modbus_t, slave: c_int) -> c_int;
    pub fn modbus_get_slave(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_set_error_recovery(ctx: *mut modbus_t,
                                     error_recovery: modbus_error_recovery_mode) -> c_int;
    pub fn modbus_set_socket(ctx: *mut modbus_t, s: c_int) -> c_int;
    pub fn modbus_get_socket(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_get_response_timeout(ctx: *mut modbus_t,
                                       to_sec: *mut uint32_t,
                                       to_usec: *mut uint32_t) -> c_int;
    pub fn modbus_set_response_timeout(ctx: *mut modbus_t, to_sec: uint32_t,
                                       to_usec: uint32_t) -> c_int;
    pub fn modbus_get_byte_timeout(ctx: *mut modbus_t, to_sec: *mut uint32_t,
                                   to_usec: *mut uint32_t) -> c_int;
    pub fn modbus_set_byte_timeout(ctx: *mut modbus_t, to_sec: uint32_t,
                                   to_usec: uint32_t) -> c_int;
    pub fn modbus_get_header_length(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_connect(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_close(ctx: *mut modbus_t);
    pub fn modbus_free(ctx: *mut modbus_t);
    pub fn modbus_flush(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_set_debug(ctx: *mut modbus_t, flag: c_int) -> c_int;
    pub fn modbus_strerror(errnum: c_int) -> *const c_char;
    pub fn modbus_read_bits(ctx: *mut modbus_t, addr: c_int,
                            nb: c_int, dest: *mut uint8_t) -> c_int;
    pub fn modbus_read_input_bits(ctx: *mut modbus_t,
                                  addr: c_int,
                                  nb: c_int,
                                  dest: *mut uint8_t) -> c_int;
    pub fn modbus_read_registers(ctx: *mut modbus_t,
                                 addr: c_int,
                                 nb: c_int,
                                 dest: *mut uint16_t) -> c_int;
    pub fn modbus_read_input_registers(ctx: *mut modbus_t,
                                       addr: c_int,
                                       nb: c_int,
                                       dest: *mut uint16_t) -> c_int;
    pub fn modbus_write_bit(ctx: *mut modbus_t,
                            coil_addr: c_int,
                            status: c_int) -> c_int;
    pub fn modbus_write_register(ctx: *mut modbus_t,
                                 reg_addr: c_int,
                                 value: c_int) -> c_int;
    pub fn modbus_write_bits(ctx: *mut modbus_t, addr: c_int,
                             nb: c_int, data: *const uint8_t) -> c_int;
    pub fn modbus_write_registers(ctx: *mut modbus_t,
                                  addr: c_int,
                                  nb: c_int,
                                  data: *const uint16_t) -> c_int;
    pub fn modbus_mask_write_register(ctx: *mut modbus_t,
                                      addr: c_int,
                                      and_mask: uint16_t, or_mask: uint16_t) -> c_int;
    pub fn modbus_write_and_read_registers(ctx: *mut modbus_t,
                                           write_addr: c_int,
                                           write_nb: c_int,
                                           src: *const uint16_t,
                                           read_addr: c_int,
                                           read_nb: c_int,
                                           dest: *mut uint16_t) -> c_int;
    pub fn modbus_report_slave_id(ctx: *mut modbus_t,
                                  max_dest: c_int,
                                  dest: *mut uint8_t) -> c_int;
    pub fn modbus_mapping_new_start_address(start_bits: c_uint,
                                            nb_bits: c_uint,
                                            start_input_bits: c_uint,
                                            nb_input_bits: c_uint,
                                            start_registers: c_uint,
                                            nb_registers: c_uint,
                                            start_input_registers: c_uint,
                                            nb_input_registers: c_uint) -> *mut modbus_mapping_t;
    pub fn modbus_mapping_new(nb_bits: c_int,
                              nb_input_bits: c_int,
                              nb_registers: c_int,
                              nb_input_registers: c_int) -> *mut modbus_mapping_t;
    pub fn modbus_mapping_free(mb_mapping: *mut modbus_mapping_t);
    pub fn modbus_send_raw_request(ctx: *mut modbus_t, raw_req: *mut uint8_t,
                                   raw_req_length: c_int) -> c_int;
    pub fn modbus_receive(ctx: *mut modbus_t, req: *mut uint8_t) -> c_int;
    pub fn modbus_receive_confirmation(ctx: *mut modbus_t, rsp: *mut uint8_t) -> c_int;
    pub fn modbus_reply(ctx: *mut modbus_t, req: *const uint8_t,
                        req_length: c_int,
                        mb_mapping: *mut modbus_mapping_t) -> c_int;
    pub fn modbus_reply_exception(ctx: *mut modbus_t, req: *const uint8_t,
                                  exception_code: c_uint) -> c_int;
    pub fn modbus_set_bits_from_byte(dest: *mut uint8_t,
                                     idx: c_int,
                                     value: uint8_t);
    pub fn modbus_set_bits_from_bytes(dest: *mut uint8_t,
                                      idx: c_int,
                                      nb_bits: c_uint,
                                      tab_byte: *const uint8_t);
    pub fn modbus_get_byte_from_bits(src: *const uint8_t,
                                     idx: c_int,
                                     nb_bits: c_uint) -> uint8_t;
    pub fn modbus_get_float(src: *const uint16_t) -> f32;
    pub fn modbus_get_float_abcd(src: *const uint16_t) -> f32;
    pub fn modbus_get_float_dcba(src: *const uint16_t) -> f32;
    pub fn modbus_get_float_badc(src: *const uint16_t) -> f32;
    pub fn modbus_get_float_cdab(src: *const uint16_t) -> f32;
    pub fn modbus_set_float(f: f32, dest: *mut uint16_t);
    pub fn modbus_set_float_abcd(f: f32, dest: *mut uint16_t);
    pub fn modbus_set_float_dcba(f: f32, dest: *mut uint16_t);
    pub fn modbus_set_float_badc(f: f32, dest: *mut uint16_t);
    pub fn modbus_set_float_cdab(f: f32, dest: *mut uint16_t);
    pub fn modbus_new_tcp(ip_address: *const c_char, port: c_int) -> *mut modbus_t;
    pub fn modbus_tcp_listen(ctx: *mut modbus_t,
                             nb_connection: c_int) -> c_int;
    pub fn modbus_tcp_accept(ctx: *mut modbus_t,
                             s: *mut c_int) -> c_int;
    pub fn modbus_new_tcp_pi(node: *const c_char,
                             service: *const c_char) -> *mut modbus_t;
    pub fn modbus_tcp_pi_listen(ctx: *mut modbus_t,
                                nb_connection: c_int) -> c_int;
    pub fn modbus_tcp_pi_accept(ctx: *mut modbus_t,
                                s: *mut c_int) -> c_int;
    pub fn modbus_new_rtu(device: *const c_char,
                          baud: c_int,
                          parity: c_char,
                          data_bit: c_int,
                          stop_bit: c_int) -> *mut modbus_t;
    pub fn modbus_rtu_set_serial_mode(ctx: *mut modbus_t,
                                      mode: c_int) -> c_int;
    pub fn modbus_rtu_get_serial_mode(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_rtu_set_rts(ctx: *mut modbus_t, mode: c_int) -> c_int;
    pub fn modbus_rtu_get_rts(ctx: *mut modbus_t) -> c_int;
    pub fn modbus_rtu_set_custom_rts(ctx: *mut modbus_t,
                                     set_rts:
                                         ::std::option::Option<unsafe extern "C" fn(ctx: *mut modbus_t,
                                                                                    on: c_int)>)
     -> c_int;
    pub fn modbus_rtu_set_rts_delay(ctx: *mut modbus_t,
                                    us: c_int) -> c_int;
    pub fn modbus_rtu_get_rts_delay(ctx: *mut modbus_t) -> c_int;
}

